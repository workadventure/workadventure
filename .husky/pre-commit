#!/bin/bash
. "$(dirname "$0")/_/husky.sh"

# Fonction pour v√©rifier la compl√©tude des traductions
check_translations() {
  cd play || exit 1
  
  HAS_ERRORS=0
  echo "=== RECENSEMENT COMPLET DES FICHIERS INCOMPLETS ==="
  echo ""
  echo "üìÅ D√©tection automatique des langues dans src/i18n/..."
  
  # D√©tecter toutes les langues (dossiers dans i18n, sauf en-US qui est la r√©f√©rence)
  LANGUAGES=$(find src/i18n -mindepth 1 -maxdepth 1 -type d -not -name "en-US" -exec basename {} \; | sort)
  
  # Compter le nombre de langues
  LANG_COUNT=$(echo "$LANGUAGES" | wc -l | tr -d ' ')
  echo "‚úÖ Langues d√©tect√©es: $LANG_COUNT"
  echo "   $(echo "$LANGUAGES" | tr '\n' ' ')"
  echo ""
  echo "üìÑ Fichier de r√©f√©rence: en-US"
  echo ""
  
  # D√©tecter tous les fichiers dans en-US
  REFERENCE_FILES=$(find src/i18n/en-US -maxdepth 1 -name "*.ts" -type f -exec basename {} .ts \; | sort)
  
  # Fonction Python pour extraire les cl√©s d'un fichier
  extract_keys() {
    local filepath="$1"
    python3 - "$filepath" << 'PYTHON_EOF'
import re
import sys
import os

# Get the filepath from command line argument
if len(sys.argv) < 2:
    sys.exit(1)

filepath = sys.argv[1]

def extract_keys_from_file(filepath):
    """Extract all keys from a TypeScript translation file with their full path (recursive)"""
    if not os.path.exists(filepath):
        return set()
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception:
        return set()
    
    # Remove single-line comments (but preserve line structure)
    lines = content.split('\n')
    cleaned_lines = []
    for line in lines:
        # Remove comments, but keep the line structure
        comment_pos = line.find('//')
        if comment_pos >= 0:
            # Check if // is inside a string
            before_comment = line[:comment_pos]
            quote_count = before_comment.count('"') + before_comment.count("'") + before_comment.count('`')
            if quote_count % 2 == 0:  # Even number means we're outside strings
                line = line[:comment_pos]
        cleaned_lines.append(line)
    content = '\n'.join(cleaned_lines)
    
    # Remove multi-line comments
    content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
    
    # Extract keys with their full path recursively
    keys = set()
    lines = content.split('\n')
    current_path = []
    indent_stack = []
    
    i = 0
    while i < len(lines):
        line = lines[i]
        stripped = line.strip()
        
        # Skip imports, const declarations, export, etc.
        if not stripped or \
           stripped.startswith('import') or \
           (stripped.startswith('const') and '=' in stripped and ':' not in stripped.split('=')[0]) or \
           stripped.startswith('export') or \
           stripped.startswith('type'):
            i += 1
            continue
        
        # Skip standalone braces
        if stripped == '{' and not any(c.isalnum() or c in '_:' for c in line[:line.find('{')]):
            i += 1
            continue
        
        # Calculate indentation (spaces only, not tabs)
        indent = len(line) - len(line.lstrip())
        
        # Match key: pattern (word followed by colon)
        # This regex matches: key: or "key": or 'key':
        match = re.match(r'^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:', line)
        if match:
            key = match.group(1)
            
            # Update path based on indentation
            # Remove deeper levels when we go back to a shallower level
            while indent_stack and len(indent_stack) > 0 and indent_stack[-1] >= indent:
                indent_stack.pop()
                if current_path:
                    current_path.pop()
            
            current_path.append(key)
            indent_stack.append(indent)
            
            # Create full path
            full_path = '.'.join(current_path)
            keys.add(full_path)
        
        # Handle closing braces - check if this line closes an object
        if stripped == '}' or stripped == '};' or (stripped.endswith('},') and not stripped.startswith('}')):
            # Find the matching opening brace by looking at indentation
            if indent_stack and len(indent_stack) > 0:
                # We're closing an object at this indentation level
                # Pop until we find the matching level
                while indent_stack and indent_stack[-1] >= indent:
                    indent_stack.pop()
                    if current_path:
                        current_path.pop()
        
        i += 1
    
    return keys

keys = extract_keys_from_file(filepath)

# Output keys one per line
for key in sorted(keys):
    print(key)
PYTHON_EOF
  }
  
  # Parcourir chaque fichier de r√©f√©rence
  for file in $REFERENCE_FILES; do
    ref_file="src/i18n/en-US/$file.ts"
    
    # V√©rifier que le fichier existe
    if [ ! -f "$ref_file" ]; then
      continue
    fi
    
    # Extraire les cl√©s de r√©f√©rence
    ref_keys=$(extract_keys "$ref_file")
    ref_key_count=$(echo "$ref_keys" | grep -v '^$' | wc -l | tr -d ' ')
    if [ -z "$ref_key_count" ] || [ "$ref_key_count" = "0" ]; then
      ref_key_count=0
    fi
    
    # Ignorer les fichiers vides
    if [ "$ref_key_count" -eq 0 ]; then
      continue
    fi
    
    echo "üìÑ $file.ts (en-US: $ref_key_count cl√©s):"
    incomplete_found=false
    
    # V√©rifier chaque langue d√©tect√©e
    for lang in $LANGUAGES; do
      lang_file="src/i18n/$lang/$file.ts"
      
      if [ ! -f "$lang_file" ]; then
        echo "  ‚ùå $lang: FICHIER MANQUANT"
        incomplete_found=true
        HAS_ERRORS=1
      else
        # Extraire les cl√©s de la langue
        lang_keys=$(extract_keys "$lang_file")
        lang_key_count=$(echo "$lang_keys" | grep -v '^$' | wc -l | tr -d ' ')
        if [ -z "$lang_key_count" ] || [ "$lang_key_count" = "0" ]; then
          lang_key_count=0
        fi
        
        # Comparer les cl√©s
        tmp_ref="/tmp/ref_keys_$$.txt"
        tmp_lang="/tmp/lang_keys_$$.txt"
        echo "$ref_keys" | sort > "$tmp_ref"
        echo "$lang_keys" | sort > "$tmp_lang"
        missing_keys=$(comm -23 "$tmp_ref" "$tmp_lang" 2>/dev/null)
        rm -f "$tmp_ref" "$tmp_lang"
        missing_count=$(echo "$missing_keys" | grep -v '^$' | wc -l | tr -d ' ')
        if [ -z "$missing_count" ] || [ "$missing_count" = "0" ]; then
          missing_count=0
        fi
        
        if [ "$missing_count" -gt 0 ] && [ "$ref_key_count" -gt 0 ]; then
          percentage=$((lang_key_count * 100 / ref_key_count))
          echo "  ‚ö†Ô∏è  $lang: $lang_key_count/$ref_key_count cl√©s ($percentage% complet, $missing_count cl√©(s) manquante(s))"
          echo "$missing_keys" | head -15 | while read -r key; do
            echo "     - $key"
          done
          if [ "$missing_count" -gt 15 ]; then
            remaining=$((missing_count - 15))
            echo "     ... et $remaining autre(s) cl√©(s)"
          fi
          incomplete_found=true
          HAS_ERRORS=1
        else
          echo "  ‚úÖ $lang: Toutes les cl√©s pr√©sentes"
        fi
      fi
    done
    
    if [ "$incomplete_found" = false ]; then
      echo "  ‚úÖ Toutes les langues compl√®tes"
    fi
    echo ""
  done
  
  echo "=== R√âSUM√â PAR LANGUE ==="
  echo ""
  for lang in $LANGUAGES; do
    total_files=0
    complete_files=0
    missing_files=0
    incomplete_files=0
    
    for file in $REFERENCE_FILES; do
      ref_file="src/i18n/en-US/$file.ts"
      lang_file="src/i18n/$lang/$file.ts"
      
      if [ ! -f "$ref_file" ]; then
        continue
      fi
      
      # V√©rifier les cl√©s uniquement
      ref_keys=$(extract_keys "$ref_file")
      ref_key_count=$(echo "$ref_keys" | grep -v '^$' | wc -l | tr -d ' ')
      if [ -z "$ref_key_count" ] || [ "$ref_key_count" = "0" ]; then
        ref_key_count=0
      fi
      
      if [ "$ref_key_count" -eq 0 ]; then
        continue
      fi
      
      total_files=$((total_files + 1))
      
      if [ ! -f "$lang_file" ]; then
        missing_files=$((missing_files + 1))
      else
        # V√©rifier les cl√©s
        lang_keys=$(extract_keys "$lang_file")
        tmp_ref="/tmp/ref_keys_$$.txt"
        tmp_lang="/tmp/lang_keys_$$.txt"
        echo "$ref_keys" | sort > "$tmp_ref"
        echo "$lang_keys" | sort > "$tmp_lang"
        missing_keys=$(comm -23 "$tmp_ref" "$tmp_lang" 2>/dev/null)
        rm -f "$tmp_ref" "$tmp_lang"
        missing_count=$(echo "$missing_keys" | grep -v '^$' | wc -l | tr -d ' ')
        if [ -z "$missing_count" ] || [ "$missing_count" = "0" ]; then
          missing_count=0
        fi
        
        if [ "$missing_count" -gt 0 ]; then
          incomplete_files=$((incomplete_files + 1))
        else
          complete_files=$((complete_files + 1))
        fi
      fi
    done
    
    if [ "$total_files" -gt 0 ]; then
      completion_rate=$((complete_files * 100 / total_files))
      echo "üåç $lang: $complete_files/$total_files fichiers complets ($completion_rate%)"
      if [ "$missing_files" -gt 0 ]; then
        echo "   ‚ùå $missing_files fichier(s) manquant(s)"
        HAS_ERRORS=1
      fi
      if [ "$incomplete_files" -gt 0 ]; then
        echo "   ‚ö†Ô∏è  $incomplete_files fichier(s) incomplet(s)"
        HAS_ERRORS=1
      fi
    fi
  done
  
  echo ""
  if [ "$HAS_ERRORS" -eq 1 ]; then
    echo "‚ùå ERREUR: Des traductions sont incompl√®tes ou manquantes !"
    echo "   Veuillez compl√©ter les fichiers de traduction avant de continuer."
    exit 1
  else
    echo "‚úÖ Toutes les traductions sont compl√®tes !"
  fi
}

(
cd messages || exit
npm run precommit
)
(
cd play || exit
npm run precommit
)
(
check_translations
)
(
cd back || exit
npm run precommit
)
(
cd map-storage || exit
npm run precommit
)
(
cd tests || exit
npm run precommit
)
(
cd libs/map-editor || exit
npm run precommit
)
(
cd libs/shared-utils || exit
npm run precommit
)
(
cd libs/store-utils || exit
npm run precommit
)
(
cd contrib/tools/generate-env-docs || exit
npm run generate
)
